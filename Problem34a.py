# Method 1
# upper bound: seven digits b/c smallest eight digit number > 8 * 9!
# lower bound: two digits so sum
# use digit multiset to cut down on search space
# use f(x) == x as test whether acceptable

import itertools as it
import functools as ft

# Generate factorials for easy reference
facs = [1]
while len(facs) < 10:
  facs.append(facs[-1] * len(facs))

# Dummy digit '10' w/ factorial 0 that allows us to simulate the null digit
facs.append(0)
digits = [0,1,2,3,4,5,6,7,8,9, 10]

# dF(x) == x is a necessary condition of x being a solution
def digitFactorial(num):
  sum = 0
  while num > 0:
    sum += facs[num % 10]
    num //= 10
  return sum

sum=0
solutions = set() # The same solutions will be generated by different multisets

# We only have to check up to seven digits due to the upper bound
# We ignore trying 0 as a digit because that will come out in factorialSum anyway

for digitCombination in it.combinations_with_replacement(digits[1:], 7):
  factorialSum = ft.reduce(lambda x, y: x+y, map(lambda x: facs[x], digitCombination))
  if factorialSum == digitFactorial(factorialSum) and factorialSum not in solutions and factorialSum >= 10:
    solutions.add(factorialSum)
    sum += factorialSum

print(sum)